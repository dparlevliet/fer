// inclusions
require('./cortex/js_extensions.js');

// this registers global.fer
/* global fer */
require('./cortex/global_fer.js');

// this registers global.components
require('./cortex/global_components.js');

// Wait for Fer to tell you she's ready to begin
fer.on('ready', function() {
  // Work out which device this is and get the config
  fer.FileUtils.walkSumList([
    '{1}/../usr/devices/'.format(__dirname)
  ]).then(function(devices) {
    fer.reduce(devices[0], function(deviceFile, offset, deferred) {
      console.log(deviceFile.path);
      if (deviceFile.path.indexOf('.gitkeep') > -1) {
        return deferred.resolve(); // skip the .gitkeep file
      }
      var device = require(deviceFile.path);
      fer.do(function(deferred) {
        device.detect(fer.deviceInfo, deferred);
      }).then(function(matches) {
        if (matches) {
          processDevice(device).then(function() {
            deferred.resolve();
          });
        } else {
          deferred.resolve();
        }
      });
    }).then(function() {
      var events = fer.getEvents('beforeDone');
      var done = function() {
        fer.log(0, "Fer: I'm done.");
        fer.memory.save();
      };
      if (events) {
        fer.reduce(events, function(event, offset, deferred) {
          event().then(function() {
            deferred.resolve();
          });
        }).then(function() {
          done();
        });
      } else {
        done();
      }
    });
  });
});


function processDevice(device) {
  return fer.do(function(deferred) {
    // Start parsing and running the device config
    var queue           = []; // used for temporary storage
    var final_queue     = []; // used for working out the final order

    // The function that handles processing the unordered queue generated by the
    // config parser.
    var runQueue = function(queue) {
      fer.memory.load();

      // Safely inserts an item in to the correct place of the final queue
      //
      // It's assumed that any items that have the same position are not related
      // to eachother and the order that they execute is irrelevant.
      var insertIntoFinalQueue = function(item) {
        if (typeof(final_queue[item.position]) !== 'undefined') {
          final_queue.splice(item.position, 0, item);
        } else {
          final_queue[item.position] = item;
        }
      };

      // Reprocesss and reorder the queue based on each item's `run_at` definition
      //
      // Each module has a priority value indicated by `run_at` in the module config.
      // However, it's possible for you to change the priority value of a config
      // modules execution so we must resolve these. Additionally, we must do it
      // in a way where twinned positions do not conflict with eachother.
      fer.reduce(queue, function(item, offset, deferred) {
        if (
          !fer.modules[item.module_name].forEach &&
          !fer.modules[item.module_name].run_at
        ) {
          // Sigh, this is likely a custom module and the creator is "uninformed".
          // Let's produce a warning and thencompensate by giving it a high value.
          console.warn('!WARNING! Module {1} has not provided a run_at value. Please provide one.'.format(item.module_name));
          fer.modules[item.module_name].run_at = 100000;
        }

        fer.value(fer.modules[item.module_name].run_at).then(function(d_position) {
          var config = item.config;
          fer.do(function(deferred) {
            if (config.forEach) {
              config.forEach(function(x_config, x_offset) {
                fer.value(x_config.run_at).then(function(position) {
                  var n_item = Object.assign({}, item);
                  n_item.config = x_config;
                  n_item.position = Number(position);
                  insertIntoFinalQueue(n_item);
                  if (x_offset == config.length - 1) {
                    deferred.resolve();
                  }
                });
              });
            } else {
              deferred.resolve();
            }
          }).then(function() {
            return fer.do(function(deferred) {
              if (!config.forEach) {
                var position = d_position;
                if (config.run_at) {
                  // Looks like the user has provided their own position for this. Use this
                  // value instead.
                  fer.value(config.run_at).then(function(position) {
                    deferred.resolve(position);
                  });
                } else {
                  deferred.resolve(position);
                }
              } else {
                deferred.resolve();
              }
            });
          }).then(function(position) {
            if (position) {
              item.position = Number(position);

              // Add it to the queue at the position defined. If an item exists at this
              // position already then this new module will simply be added before it.
              insertIntoFinalQueue(item);
            }

            // if this is the last item we will process, then we need to resolve and
            // move on
            deferred.resolve();
          });
        });
      }).then(function() {
        return fer.reduce(final_queue, function(item, offset, deferred) {
          if (!item) {
            return deferred.resolve();
          }

          var start = (new Date()).getTime();
          fer.log(0, '{1}-{2}> Starting'.format(item.position, item.module_name));

          // remove run_at, because the module doesn't need to be confused by it.
          if (item.config.run_at) {
            delete item.config.run_at;
          }

          try {
            fer.modules[item.module_name].cls(item.config, function() {
              var now = (new Date()).getTime();
              fer.log(0, '{1}-{2}> Completed in {3}ms'.format(item.position, item.module_name, (now-start)));
              deferred.resolve();
            });
          } catch (e) {
            fer.log(0, '!ERROR! {1}'.format(e.message), 1);
            var now = (new Date()).getTime();
            fer.log(0, '{1}-{2}> Completed in {3}ms'.format(item.position, item.module_name, (now-start)));
            deferred.resolve();
          }
        });
      }).then(function() {
        deferred.resolve();
      });
    };

    // Parse the device config and any inherited components
    fer.do(function(deferred) {
      if (device.inherit) {
        // find and parse all inherited configs
        var length = device.inherit.length;
        if (length == 0) {
          return deferred.resolve();
        }

        fer.reduce(device.inherit, function(component, offset, deferred) {
          component.then(function(config) {
            fer.reduce(Object.keys(config), function(module_name, offset, _deferred) {
              if (fer.modules[module_name]) {
                fer.value(config[module_name]).then(function(config) {
                  queue.push({
                    module_name: module_name,
                    config: config
                  });
                  _deferred.resolve();
                });
              } else {
                console.warn('!WARNING! Module for ' + module_name + ' not found.');
              }
            }).then(function() {
              deferred.resolve();
            });
          });
        }).then(function() {
          deferred.resolve();
        });
      } else {
        deferred.resolve();
      }
    }).then(function() {
      return fer.do(function(deferred) {
        // parse the device config
        if (Object.keys(device.config).length == 0) {
          return deferred.resolve();
        }

        fer.reduce(Object.keys(device.config), function(module_name, offset, deferred) {
          if (fer.modules[module_name]) {
            queue.push({
              module_name: module_name,
              config: device.config[module_name]
            });
          } else {
            console.warn('!WARNING! Module for ' + module_name + ' not found.');
          }

          deferred.resolve();
        }).then(function() {
          deferred.resolve();
        });
      });
    }).then(function() {
      if (device.single_config !== true) {
        // We don't need to process the config any futher, we can start the queue
        runQueue(queue);
      } else {
        // The user has opted to use a single config structure, which means
        // merging all inherited configs and device configs down to a single
        // configuration struct.
        fer.do(function(deferred) {
          var final_config = {};
          var waiting = [];
          waiting.reduce(function(n1, n2, offset) {
            if (queue.length - 1 == offset) {
              deferred.resolve(final_config);
            }
          }, fer.Q(fer.do(function() {
            queue.forEach(function(item, offset) {
              waiting.push(fer.do(function(d2) {
                var config = {};
                if (final_config[item.module_name]) {
                  config = final_config[item.module_name];
                } else {
                  final_config[item.module_name] = item.config;
                }

                // due to run_at it's possible for two configs to exist from the
                // same module and expect to be run at different positions in the
                // queue -- this causes an issue with a singular config sytem
                fer.do(function(d3) {
                  if (
                    config.run_at &&
                    item.config.run_at &&
                    config.run_at != item.config.run_at
                  ) {
                    // found two module configs that are set to run at different
                    // positions in the queue. We must convert this module config
                    // to a list object to preserve integrity.
                    final_config[item.module_name] = [
                      config,
                      item.config
                    ];
                    d3.resolve();
                  } else if (config.forEach) {
                    // oooh boy. We found a config entry for a module that
                    // already has a list of configs set to run at different
                    // times. We need to go through each of these and see if this
                    // one is set to run at the same time as any of the others.
                    // If not, we add it to the queue, if so then we merge them.
                    var n_config = [];
                    config.forEach(function(value, offset) {
                      if (
                        value.run_at &&
                        item.config.run_at &&
                        value.run_at == item.config.run_at
                      ) {
                        // found a config entry that matches the run period of
                        // this one.
                        fer.config_merge_left(
                          value,
                          item.config
                        ).then(function(value) {
                          n_config[offset] = value;
                          d3.resolve();
                        });
                      } else if (!value.run_at && !item.config.run_at) {
                        // neither of these configs are set to run at a specific
                        // period so it will end up defaulting back to the module
                        // specification. It's safe to merge these two
                      } else {
                        // this is a new period of definition, add it to the list
                        n_config.push(value);
                        d3.resolve();
                      }
                    });
                  } else {
                    // normal situation, just merge them then move on
                    fer.config_merge_left(
                      config,
                      item.config
                    ).then(function(n_config) {
                      final_config[item.module_name] = n_config;
                      d3.resolve();
                    });
                  }
                }).then(function() {
                  // this one is done, call up the next
                  d2.resolve();
                });
              }));
            });
          })));
        }).then(function(final_config) {
          return fer.do(function(deferred) {
            // reset the queue
            queue = [];
            for (var module_name in final_config) {
              queue.push({
                module_name: module_name,
                config: final_config[module_name]
              });
            }
            deferred.resolve(queue);
          });
        }).then(function(queue) {
          runQueue(queue);
        });
      }
    });
  });
};