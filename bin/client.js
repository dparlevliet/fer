
// inclusions
require('./cortex/js_extensions.js');

// this registers global.fer
/* global fer */
require('./cortex/global_fer.js');
fer.argv = require('yargs').argv;


// Wait for Fer to tell you she's ready to begin
fer.on('ready', function() {
  // this registers global.components
  try {
    var components = require('./cortex/components.js');
    (new components()).then(function(components) {
      global.components = components;
      // Work out which device this is and get the config
      fer.FileUtils.walkSumList([
        '{1}/../usr/devices/'.format(__dirname)
      ]).then(function(devices) {
        fer.reduce(devices[0], function(deviceFile, offset, deferred) {
          if (deviceFile.path.indexOf('.gitkeep') > -1) {
            return deferred.resolve(); // skip the .gitkeep file
          }
          var device = require(deviceFile.path);
          fer.do(function(deferred) {
            device.detect(fer.deviceInfo, deferred);
          }).then(function(matches) {
            if (matches) {
              processDevice(device).then(function() {
                deferred.resolve();
              });
            } else {
              deferred.resolve();
            }
          }).fail(function(e) {
            console.log(e);
            deferred.resolve();
          });
        }).then(function() {
          var events = fer.getEvents('beforeDone');
          var done = function() {
            fer.log(0, "Fer: I'm done.");
            fer.memory.save();
          };
          if (events) {
            fer.reduce(events.reverse(), function(event, offset, deferred) {
              event().then(function() {
                deferred.resolve();
              }).fail(function(e) {
                console.log(e);
                deferred.resolve();
              });
            }).then(function() {
              done();
            }).fail(function(e) {
              console.log(e);
              done();
            });
          } else {
            done();
          }
        }).fail(function(e) {
          console.log(e);
        });
      });
    });
  } catch (e) {
    console.log(e);
  }
});


function processDevice(device) {
  return fer.do(function(deferred) {
    // Start parsing and running the device config
    var queue           = []; // used for temporary storage
    var final_queue     = []; // used for working out the final order

    // The function that handles processing the unordered queue generated by the
    // config parser.
    var runQueue = function(queue) {
      fer.memory.load();

      // Safely inserts an item in to the correct place of the final queue
      //
      // It's assumed that any items that have the same position are not related
      // to eachother and the order that they execute is irrelevant.
      var insertIntoFinalQueue = function(item) {
        if (typeof(final_queue[item.position]) !== 'undefined') {
          final_queue.splice(item.position, 0, item);
        } else {
          final_queue[item.position] = item;
        }
      };

      // Reprocesss and reorder the queue based on each item's `run_at` definition
      //
      // Each module has a priority value indicated by `run_at` in the module config.
      // However, it's possible for you to change the priority value of a config
      // modules execution so we must resolve these. Additionally, we must do it
      // in a way where twinned positions do not conflict with eachother.
      fer.reduce(queue, function(item, offset, deferred) {
        if (
          !fer.modules[item.module_name].forEach &&
          !fer.modules[item.module_name].run_at
        ) {
          // Sigh, this is likely a custom module and the creator is "uninformed".
          // Let's produce a warning and thencompensate by giving it a high value.
          console.warn('!WARNING! Module {1} has not provided a run_at value. Please provide one.'.format(item.module_name));
          fer.modules[item.module_name].run_at = 100000;
        }

        fer.value(fer.modules[item.module_name].run_at).then(function(d_position) {
          var config = item.config;
          fer.do(function(deferred) {
            if (config.forEach) {
              fer.reduce(config, function(x_config, x_offset, _deferred) {
                fer.value(x_config.run_at).then(function(position) {
                  if (!position) {
                    position = 100000;
                  }
                  var n_item = Object.assign({}, item);
                  n_item.config = x_config;
                  n_item.position = Number(position);
                  insertIntoFinalQueue(n_item);
                  _deferred.resolve();
                });
              }).then(function() {
                deferred.resolve();
              });
            } else {
              deferred.resolve();
            }
          }).then(function() {
            return fer.do(function(deferred) {
              if (!config.forEach) {
                var position = d_position;
                if (config.run_at) {
                  // Looks like the user has provided their own position for this. Use this
                  // value instead.
                  fer.value(config.run_at).then(function(position) {
                    deferred.resolve(position);
                  });
                } else {
                  deferred.resolve(position);
                }
              } else {
                deferred.resolve();
              }
            });
          }).then(function(position) {
            if (position) {
              item.position = Number(position);

              // Add it to the queue at the position defined. If an item exists at this
              // position already then this new module will simply be added before it.
              insertIntoFinalQueue(item);
            }

            // if this is the last item we will process, then we need to resolve and
            // move on
            deferred.resolve();
          });
        });
      }).then(function() {
        return fer.reduce(final_queue, function(item, offset, deferred) {
          if (!item) {
            return deferred.resolve();
          }

          var start = (new Date()).getTime();
          fer.log(0, '{1}-{2}> Starting'.format(item.position, item.module_name));

          // remove run_at, because the module doesn't need to be confused by it.
          if (item.config.run_at) {
            delete item.config.run_at;
          }

          try {
            fer.modules[item.module_name].cls(item.config, function() {
              var now = (new Date()).getTime();
              fer.log(0, '{1}-{2}> Completed in {3}ms'.format(item.position, item.module_name, (now-start)));
              deferred.resolve();
            });
          } catch (e) {
            fer.log(0, '!ERROR! {1}'.format(e.message), 1);
            var now = (new Date()).getTime();
            fer.log(0, '{1}-{2}> Completed in {3}ms'.format(item.position, item.module_name, (now-start)));
            deferred.resolve();
          }
        });
      }).then(function() {
        deferred.resolve();
      }).fail(function(e) {
        console.log(e);
      });
    };

    // Parse the device config and any inherited components
    fer.do(function(deferred) {
      if (device.inherit) {
        // find and parse all inherited configs
        var runComponent = function(componentDevice) {
          return fer.do(function(deferred) {
            if (!componentDevice.inherit) {
              componentDevice.inherit = function() { return []; };
            }
            if (typeof(componentDevice.inherit) === 'function') {
              componentDevice.inherit = componentDevice.inherit();
            }
            if (!componentDevice.inherit) {
              componentDevice.inherit = [];
            }
            fer.reduce(componentDevice.inherit, function(component, offset, deferred) {
              component.then(function(componentConfig) {
                runComponent(componentConfig).then(function() {
                  deferred.resolve();
                }).fail(function(e) {
                  console.log(e);
                });
              });
            }).then(function() {
              fer.reduce(Object.keys(componentDevice.config), function(module_name, offset, _deferred) {
                if (!fer.modules[module_name]) {
                  console.warn('!WARNING! Module for ' + module_name + ' not found.');
                  return _deferred.resolve();
                }
                fer.value(componentDevice.config[module_name]).then(function(config) {
                  if (config && !config.run_at) {
                    // inject the default run_at because the user didn't
                    // explicitly define a run_at period. This is necessary to
                    // properly generate a well merged single-config and
                    // also to give the user a clear picture of the run times
                    // when they use ``--view-config``.
                    if (typeof(fer.modules[module_name].run_at) === 'function') {
                      config.run_at = fer.modules[module_name].run_at();
                    } else {
                      config.run_at = fer.modules[module_name].run_at;
                    }
                  }
                  componentDevice.config[module_name] = config;

                  if (device.single_config === false) {
                    // the user has opted to not use single config so just
                    // queue the module because we wont be merging it later.
                    queue.push({
                      module_name: module_name,
                      config: config
                    });
                  }
                  _deferred.resolve();
                });
              }).then(function() {
                if (device.single_config === false) {
                  // if the user opted to not use single-config then there's
                  // no need to merge anything, just move along.
                  deferred.resolve();
                } else {
                  // merge the device config in to the component config. Uses
                  // merge_right because the base device config takes priority
                  // over any component configs so we want to ensure that.
                  return fer.config_merge_right(
                    device.config,
                    componentDevice.config
                  ).then(function(config) {
                    device.config = config;
                    deferred.resolve();
                  });
                }
              });
            });
          });
        };
        runComponent(device).then(function() {
          deferred.resolve();
        }).fail(function(e) {
          console.log(e);
        });
      } else {
        deferred.resolve();
      }
    }).then(function() {
      return fer.do(function(deferred) {
        if (fer.argv.viewConfig) {
          console.log(JSON.stringify(device.config, null, 2));
          //var util = require('util');
          //console.log(util.inspect(device.config, { showHidden: true, depth: null }));
          return deferred.resolve(true);
        }

        // parse the device config
        if (Object.keys(device.config).length == 0) {
          return deferred.resolve();
        }

        fer.reduce(Object.keys(device.config), function(module_name, offset, deferred) {
          if (fer.modules[module_name]) {
            if (
              typeof(device.config[module_name]) == 'object' &&
              device.config[module_name].forEach
            ) {
              device.config[module_name].forEach(function(config, offset) {
                queue.push({
                  module_name: module_name,
                  config: config
                });
              });
            } else {
              queue.push({
                module_name: module_name,
                config: device.config[module_name]
              });
            }
          } else {
            console.warn('!WARNING! Module for ' + module_name + ' not found.');
          }
          deferred.resolve();
        }).then(function() {
          deferred.resolve();
        });
      });
    }).then(function(skip) {
      // We don't need to process the config any futher, we can start the queue
      if (!skip) {
        runQueue(queue);
      }
    });
  });
}